<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Maximum Likelihood Estimation - Spatial Lag Model &#8212; spreg v1.8.4.dev8+g8cc5fbc Manual</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css?v=9afac83c" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pysal-styles.css?v=b100b7f1" />
    <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
    <script src="../_static/documentation_options.js?v=a961f9ea"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"equationNumbers": {"autoNumber": "AMS", "useLabelIds": true}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="icon" href="../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Instrumental Variables Estimation - Spatial Lag Model" href="14_IV_estimation_spatial_lag.html" />
    <link rel="prev" title="Estimating SLX Models" href="12_estimating_slx.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          spreg</a>
        <span class="navbar-text navbar-version pull-left"><b>1.8.4.dev8+g8cc5fbc</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../installation.html">Installation</a></li>
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../api.html">API</a></li>
                <li><a href="../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../tutorials.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1_sample_data.html">PySAL Sample Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="2_data_input_output.html">Data Input/Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="3_basic_mapping.html">Basic Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="4_spatial_weights.html">Spatial Weights</a></li>
<li class="toctree-l2"><a class="reference internal" href="5_OLS.html">Basic Ordinary Least Squares Regression (OLS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="6_TWOSLS.html">Two Stage Least Squares Regression (2SLS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="7_spatial_models.html">Spatial Model Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="8_spatial_multipliers.html">Spatial Multipliers</a></li>
<li class="toctree-l2"><a class="reference internal" href="9_specification_tests.html">Specification Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="10_specification_tests_properties.html">Specification Tests - Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="11_distance_decay.html">Distance Decay</a></li>
<li class="toctree-l2"><a class="reference internal" href="12_estimating_slx.html">Estimating SLX Models</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Maximum Likelihood Estimation - Spatial Lag Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_IV_estimation_spatial_lag.html">Instrumental Variables Estimation - Spatial Lag Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="15_ML_estimation_spatial_error.html">Maximum Likelihood Estimation - Spatial Error Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_GMM_estimation_spatial_error.html">GMM Estimation - Spatial Error Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_GMM_higher_order.html">GMM Estimation - Higher Order Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="Panel_FE_example.html">Spatial Panel Models with Fixed Effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="skater_reg.html">Skater Regression</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../api.html#classic-models">Classic Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#spatial-regression-models">Spatial Regression Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#discrete-choice-models">Discrete Choice Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#regimes-models">Regimes Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#seemingly-unrelated-regressions">Seemingly-Unrelated Regressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#spatial-panel-models">Spatial Panel Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#diagnostics">Diagnostics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#spatial-specification-search">Spatial Specification Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#dgp">DGP</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">References</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Maximum Likelihood Estimation - Spatial Lag Model</a><ul>
<li><a class="reference internal" href="#Luc-Anselin">Luc Anselin</a></li>
<li><a class="reference internal" href="#(revised-09/19/2024)">(revised 09/19/2024)</a><ul>
<li><a class="reference internal" href="#Preliminaries">Preliminaries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#Modules-Needed">Modules Needed</a></li>
<li><a class="reference internal" href="#Functions-Used">Functions Used</a></li>
<li><a class="reference internal" href="#Variable-definition-and-data-input">Variable definition and data input</a><ul>
<li><a class="reference internal" href="#OLS-and-SLX-with-Spatial-Diagnostics">OLS and SLX with Spatial Diagnostics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#OLS">OLS</a></li>
<li><a class="reference internal" href="#SLX">SLX</a><ul>
<li><a class="reference internal" href="#ML-Estimation-of-the-Lag-Model">ML Estimation of the Lag Model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#Principle">Principle</a></li>
<li><a class="reference internal" href="#Implementation-methods">Implementation methods</a><ul>
<li><a class="reference internal" href="#Spatial-Multipliers---Impacts">Spatial Multipliers - Impacts</a></li>
<li><a class="reference internal" href="#Predicted-Values-and-Residuals">Predicted Values and Residuals</a><ul>
<li><a class="reference internal" href="#Spatial-pattern-of-residuals">Spatial pattern of residuals</a></li>
<li><a class="reference internal" href="#Mapping-predicted-values-and-residuals">Mapping predicted values and residuals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ML-Estimation-of-Spatial-Durbin-Model">ML Estimation of Spatial Durbin Model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id2">Spatial Multipliers - Impacts</a></li>
<li><a class="reference internal" href="#Common-Factor-Hypothesis">Common Factor Hypothesis</a></li>
<li><a class="reference internal" href="#Likelihood-Ratio-Tests">Likelihood-Ratio Tests</a><ul>
<li><a class="reference internal" href="#Practice">Practice</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="admonition note">
<p>This page was generated from <a class="reference external" href="https://github.com/pysal/spreg/blob/master/notebooks/13_ML_estimation_spatial_lag.ipynb">notebooks/13_ML_estimation_spatial_lag.ipynb</a>.
Interactive online version:
<span class="raw-html"><a href="https://mybinder.org/v2/gh/pysal/spreg/master?filepath=notebooks/13_ML_estimation_spatial_lag.ipynb"><img alt="Binder badge" src="https://mybinder.org/badge_logo.svg" style="vertical-align:text-bottom"></a></span></p>
</div>
<section id="Maximum-Likelihood-Estimation---Spatial-Lag-Model">
<h1>Maximum Likelihood Estimation - Spatial Lag Model<a class="headerlink" href="#Maximum-Likelihood-Estimation---Spatial-Lag-Model" title="Link to this heading">¶</a></h1>
<section id="Luc-Anselin">
<h2>Luc Anselin<a class="headerlink" href="#Luc-Anselin" title="Link to this heading">¶</a></h2>
</section>
<section id="(revised-09/19/2024)">
<h2>(revised 09/19/2024)<a class="headerlink" href="#(revised-09/19/2024)" title="Link to this heading">¶</a></h2>
<section id="Preliminaries">
<h3>Preliminaries<a class="headerlink" href="#Preliminaries" title="Link to this heading">¶</a></h3>
<p>This notebook is the first of two that deal with the estimation of the spatial Lag model and the spatial Durbin model. Here, the Maximum Likelihood approach is illustrated. Instrumental variable estimation is considered in a separate notebook.</p>
<p>The maximum likelihood estimation in <code class="docutils literal notranslate"><span class="pre">spreg</span></code> is primarily included for pedagogical purposes. Generally, the instrumental variables approach is preferred. In addition, an optimal maximum likelihood estimation implementation, based on the Smirnov-Anselin (2001) approximation, is not currently implemented in <code class="docutils literal notranslate"><span class="pre">spreg</span></code>. It is implemented in C++ in <code class="docutils literal notranslate"><span class="pre">GeoDa</span></code>. This is the preferred approach for ML estimation in large(r) data sets, although it currently does not support estimation of the spatial
Durbin specification (this must be implemented by hand by constructing the spatially lagged explanatory variables explicitly).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">spreg</span></code> module implements ML estimation of the spatial lag model in the <code class="docutils literal notranslate"><span class="pre">ML_Lag</span></code> class. Given the problems in the optimization of the log-likelihood for the SARSAR model (and the issues with interpretation of the results), ML estimation of this model is purposely not included. For the same reason, the general nested model is not implemented either. These models can be estimated by means of IV/GMM.</p>
<p>The estimation of the Spatial Durbin model is implemented through the inclusion of the <code class="docutils literal notranslate"><span class="pre">slx_lags</span></code> argument.</p>
</section>
</section>
<section id="Modules-Needed">
<h2>Modules Needed<a class="headerlink" href="#Modules-Needed" title="Link to this heading">¶</a></h2>
<p>As before, the main module is <em>spreg</em> for spatial regression analysis. From this, <code class="docutils literal notranslate"><span class="pre">OLS</span></code> and <code class="docutils literal notranslate"><span class="pre">ML_Lag</span></code> are imported. In addition, the utilities in <em>libpysal</em> (to open spatial weights and access the sample data set), <em>pandas</em> and <em>geopandas</em> are needed, as well as <em>time</em> (for some timing results), <em>matplotlib.pyplot</em> and <em>seaborn</em> for visualization. All of these rely on <em>numpy</em> as a dependency. Finally, in order to carry out the Likelihood Ratio tests, <code class="docutils literal notranslate"><span class="pre">likratiotest</span></code> is imported from
<code class="docutils literal notranslate"><span class="pre">spreg.diagnostics</span></code>.</p>
<p>The usual <em>numpy</em> <code class="docutils literal notranslate"><span class="pre">set_printoptions</span></code> is included as well.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import warnings
warnings.filterwarnings(&quot;ignore&quot;)
import os
os.environ[&#39;USE_PYGEOS&#39;] = &#39;0&#39;

import numpy as np
import pandas as pd
import geopandas as gpd
import time
import matplotlib.pyplot as plt
import seaborn as sns
from libpysal.io import open
from libpysal.examples import get_path
from libpysal.weights import lag_spatial

from spreg import OLS, ML_Lag
from spreg.diagnostics import likratiotest
np.set_printoptions(legacy=&quot;1.25&quot;)
</pre></div>
</div>
</div>
</section>
<section id="Functions-Used">
<h2>Functions Used<a class="headerlink" href="#Functions-Used" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>from pandas/geopandas:</p>
<ul>
<li><p>read_file</p></li>
<li><p>DataFrame</p></li>
<li><p>head</p></li>
<li><p>describe</p></li>
<li><p>corr</p></li>
</ul>
</li>
<li><p>from libpysal:</p>
<ul>
<li><p>io.open</p></li>
<li><p>examples.get_path</p></li>
<li><p>weights.lag_spatial</p></li>
</ul>
</li>
<li><p>from numpy:</p>
<ul>
<li><p>hstack</p></li>
</ul>
</li>
<li><p>from matplotlib/seaborn:</p>
<ul>
<li><p>regplot</p></li>
<li><p>show</p></li>
</ul>
</li>
<li><p>from spreg:</p>
<ul>
<li><p>spreg.OLS</p></li>
<li><p>spreg.ML_Lag</p></li>
<li><p>spreg.diagnostics.likratiotest</p></li>
</ul>
</li>
</ul>
</section>
<section id="Variable-definition-and-data-input">
<h2>Variable definition and data input<a class="headerlink" href="#Variable-definition-and-data-input" title="Link to this heading">¶</a></h2>
<p>The data set and spatial weights are from the <strong>chicagoSDOH</strong> sample data set:</p>
<ul class="simple">
<li><p><strong>Chi-SDOH.shp,shx,dbf,prj</strong>: socio-economic indicators of health for 2014 in 791 Chicago tracts</p></li>
<li><p><strong>Chi-SDOH_q.gal</strong>: queen contiguity weights</p></li>
</ul>
<p>To illustrate the methods, a descriptive model is used that relates the rate of uninsured households in a tract(for health insurance, <strong>EP_UNINSUR</strong>) to the lack of high school education (<strong>EP_NOHSDP</strong>), the economic deprivation index (<strong>HIS_ct</strong>), limited command of English (<strong>EP_LIMENG</strong>) and the lack of access to a vehicle (<strong>EP_NOVEH</strong>). This is purely illustrative of a spatial lag specification and does not have a particular theoretical or policy motivation.</p>
<p>The file names and variable names are set in the usual manner. Any customization for different data sets/weights and different variables should be specified in this top cell.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>infileshp = get_path(&quot;Chi-SDOH.shp&quot;)     # input shape file with data
infileq = get_path(&quot;Chi-SDOH_q.gal&quot;)     # queen contiguity weights created with GeoDa

y_name = &#39;EP_UNINSUR&#39;
x_names = [&#39;EP_NOHSDP&#39;,&#39;HIS_ct&#39;,&#39;EP_LIMENG&#39;,&#39;EP_NOVEH&#39;]
ds_name = &#39;Chi-SDOH&#39;
w_name = &#39;Chi-SDOH_q&#39;
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">read_file</span></code> and <code class="docutils literal notranslate"><span class="pre">open</span></code> functions are used to access the sample data set and contiguity weights. The weights are row-standardized and the data frames for the dependent and explanatory variables are constructed. As before, this functionality is agnostic to the actual data sets and variables used, since it relies on the specification given in the initial block above.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>dfs = gpd.read_file(infileshp)
wq =  open(infileq).read()
wq.transform = &#39;r&#39;    # row-transform the weights
y = dfs[y_name]
x = dfs[x_names]
</pre></div>
</div>
</div>
<section id="OLS-and-SLX-with-Spatial-Diagnostics">
<h3>OLS and SLX with Spatial Diagnostics<a class="headerlink" href="#OLS-and-SLX-with-Spatial-Diagnostics" title="Link to this heading">¶</a></h3>
<p>Standard OLS and SLX regressions with spatial diagnostics are carried out to provide a point of reference. Moran’s I is included by setting <code class="docutils literal notranslate"><span class="pre">moran=True</span></code> and, of course, <code class="docutils literal notranslate"><span class="pre">spat_diag=True</span></code> as well. Refer to the specific OLS notebook for further details.</p>
</section>
</section>
<section id="OLS">
<h2>OLS<a class="headerlink" href="#OLS" title="Link to this heading">¶</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ols1 = OLS(y,x,w=wq,spat_diag=True,moran=True,
                 name_w=w_name,name_ds=ds_name)
print(ols1.summary)
</pre></div>
</div>
</div>
<p>The specification achieves an acceptable <span class="math notranslate nohighlight">\(R^2\)</span> of about 0.63 and all coefficients are positive and highly significant.</p>
<p>The non-spatial diagnostics suggest non-normality as well as a hight degree of heteroskedasticity. There is no problem with multicollinearity.</p>
<p>The spatial diagnostics against the SARERR alternatives show very significant LM-Lag and LM-Error, but of the two robust tests, only RLM-Lag is highly significant (RLM-Error only at p &lt; 0.03). Hence, there is a strong indication that a Lag rather than an Error alternative may be appropriate. While the joint LM test is also highly significant, this is likely due to a strong one-sided (Lag) alternative.</p>
<p>Interestingly, the diagnostics against a spatial Durbin alternative strongly support the latter as well. Both LM tests and their robust forms are highly significant, and so is the joint test. Moreover, the value for the robust forms of the test is smaller than the original, which is the expected behavior (although not always reflected in empirical practice).</p>
<p>In sum, in addition to a spatial Lag model as an alternative, the spatial Durbin specification deserves consideration as well.</p>
</section>
<section id="SLX">
<h2>SLX<a class="headerlink" href="#SLX" title="Link to this heading">¶</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>slx1 = OLS(y,x,w=wq,slx_lags=1,spat_diag=True,moran=True,
                 name_w=w_name,name_ds=ds_name)
print(slx1.summary)
</pre></div>
</div>
</div>
<p>Relative to the classic regression model, the fit improves slightly, but the constant, <strong>EP_NOHSDP</strong> and <strong>HIS_CT</strong> become non-significant at p = 0.01 (they are marginally signifcant at p=0.05). All but one coefficient of the SLX terms are significant (<strong>W_EP_NOVEH</strong> is not). The signs and magnitudes of the SLX coefficients relative to their unlagged counterparts remain a bit confusing. Only for <strong>EP_LIMENG</strong> and <strong>W_EP_LIMENG</strong> are they the same, with the lag coefficient smaller than the
unlagged one, in accordance with Tobler’s law. The coefficient for <strong>W_HIS_ct</strong> is significant and larger than that of <strong>HIS_ct</strong>, while the latter is not significant at p = 0.01. In other words, the interpretation of these results in terms of distance decay and Tobler’s law may be a bit problematic.</p>
<p>In terms of diagnostics, there is a slight problem with multicollinearity (often the case in SLX specifications), strong non-normality and evidence of heteroskedasticity. Moran’s I is significant, as are both LM-tests, but neither of the robust forms is significant. Based on the relative magnitudes of the test statistics, there is a slight indication of a possible Lag alternative, i.e., a spatial Durbin specification. However, this indication is not as strong as that provided by the LM-SDM test
statistics in the classic specification.</p>
<section id="ML-Estimation-of-the-Lag-Model">
<h3>ML Estimation of the Lag Model<a class="headerlink" href="#ML-Estimation-of-the-Lag-Model" title="Link to this heading">¶</a></h3>
</section>
</section>
<section id="Principle">
<h2>Principle<a class="headerlink" href="#Principle" title="Link to this heading">¶</a></h2>
<p>The point of departure of the Maximum Likelihood estimation of the spatial Lag model is an assumption of normal, independent and identically distributed errors. From this, the distribution for the observable vector of the dependent variable is obtained as multivariate normal.</p>
<p>For the lag model <span class="math notranslate nohighlight">\(y = \rho Wy + X\beta + u\)</span>, the corresponding log-likelihood is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\ln L =  \ln | I - \rho W |  -(n/2)(\ln 2\pi) - (n/2) \ln \sigma^2   \\
     - (1/2 \sigma^2)(y - \rho W y - X \beta)'(y - \rho W y - X \beta)\end{split}\]</div>
<p>Except for the first term, this is identical to the log-likelihood in the classic regression model. The maximization of the classic log-likelihood would correspond to the minimization of the sum of squared residuals, in this case <span class="math notranslate nohighlight">\((y - \rho W y - X \beta)'(y - \rho W y - X \beta)\)</span>, but this ignores the Jacobian term <span class="math notranslate nohighlight">\(\ln | I - \rho W |\)</span>. As a consequence, simple minimization of the sum of squared residuals (i.e., OLS), which ignores this Jacobian term, will yield biased estimates.</p>
<p>Maximization of the log-likelihood is simplified since a <em>concentrated</em> likelihood can be derived that is only a function of the single parameter <span class="math notranslate nohighlight">\(\rho\)</span>. Once an estimate for <span class="math notranslate nohighlight">\(\rho\)</span> is obtained, the corresponding estimates for <span class="math notranslate nohighlight">\(\beta\)</span> and <span class="math notranslate nohighlight">\(\sigma^2\)</span> are easily computed. For technical details, see Chapter 8 of Anselin and Rey (2014).</p>
<p>Inference is based on an asymptotic variance matrix, which is computed as the inverse of the so-called information matrix (the expected value of the matrix of second partial derivatives of the log-likelihood function).</p>
</section>
<section id="Implementation-methods">
<h2>Implementation methods<a class="headerlink" href="#Implementation-methods" title="Link to this heading">¶</a></h2>
<p>ML estimation of the classic spatial lag model is implemented by means of <code class="docutils literal notranslate"><span class="pre">spreg.ML_Lag</span></code>, with all the standard regression arguments (i.e., at a minimum, <strong>y</strong>, <strong>x</strong> and <strong>w</strong>). Three different methods are implemented: <code class="docutils literal notranslate"><span class="pre">full</span></code>, <code class="docutils literal notranslate"><span class="pre">ord</span></code> an <code class="docutils literal notranslate"><span class="pre">LU</span></code>. These differ only in the way the Jacobian term <span class="math notranslate nohighlight">\(\ln | I - \rho W |\)</span> is computed. As the logarithm of the determinant of a <span class="math notranslate nohighlight">\(n \times n\)</span> matrix, this calculation runs into numerical difficulties for large(r) data sets.</p>
<p>The default optimization method is <em>brute force</em>, or <code class="docutils literal notranslate"><span class="pre">method=&quot;full&quot;</span></code>. This uses dense matrix expressions to calculate the required determinants and inverse matrix terms. This method should <em>not</em> be used for large(r) data sets.</p>
<p>The Ord eigenvalue method, <code class="docutils literal notranslate"><span class="pre">method=&quot;ord&quot;</span></code> (Ord, 1975) uses the eigenvalues of the spatial weights matrix as a shortcut to compute the Jacobian determinant. Since this method relies on eigenvalue computations, it also is not reliable for large(r) data sets. The <code class="docutils literal notranslate"><span class="pre">method</span></code> argument must be included (since the default is <code class="docutils literal notranslate"><span class="pre">method=&quot;full&quot;</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">method=&quot;LU&quot;</span></code> uses the LU (Cholesky) matrix decomposition for sparse matrices to efficiently compute the Jacobian determinant for large data sets. The sparse matrix conversion is done internally, so the only needed additional argument is <code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">&quot;LU&quot;</span></code>. This is the only reliable method for larger data sets.</p>
<p>The ML estimation is illustrated for the same specification as before, first using <code class="docutils literal notranslate"><span class="pre">method=&quot;full&quot;</span></code>. Since this is also the default, it is not necessary to explicitly include this argument, but it is listed here for clarity. To compare the relative speed of the different methods, <code class="docutils literal notranslate"><span class="pre">time.time()</span></code> is used.</p>
<p>In addition, since the impacts calculation is set to <code class="docutils literal notranslate"><span class="pre">simple</span></code> by default, it is turned off for now by means of <code class="docutils literal notranslate"><span class="pre">spat_impacts</span> <span class="pre">=</span> <span class="pre">None</span></code> (see below for more specifics).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>t0 = time.time()
lag1a = ML_Lag(y,x,w=wq,method=&quot;full&quot;,
                     name_w=w_name,name_ds=ds_name,
                     spat_impacts=None)
t1 = time.time()
print(&quot;Time in seconds: &quot;,t1-t0)
print(lag1a.summary)
</pre></div>
</div>
</div>
<p>The spatial autoregressive coefficient (<strong>W_EP_UNINSUR</strong>) at 0.39 is highly significant. The effect of its inclusion on the other coefficient estimates is major as well. All are substantially smaller than in the classic regression, except for the coefficient of <strong>EP_NOVEH</strong>, which is marginally larger. The main effect is on the constant term and the coefficient of <strong>EP_NOHSDP</strong>, neither of which is any longer significant. In essence, ignoring the spatial spillover effects in the classic
regression means that some of these spillovers are reflected in the regression coefficients, which become biased with respect to their true magnitude. The spillover effects are considered more closely in the discussion of impacts below.</p>
<p>In addition to the coefficient estimates, the output includes information about the model fit. There are two <strong>Pseudo R-squared</strong> measures: one is based on the <em>naive residuals</em>, <span class="math notranslate nohighlight">\(e = y - \hat{\rho} Wy - X\hat{\beta}\)</span>, the other (<strong>Spatial Pseudo R-squared</strong>) is computed from the forecasting errors when using the reduced form to compute predicted values. The two types of predicted values and residuals are included in the regression object as <strong>predy</strong> and <strong>u</strong> for the naive form and
<strong>predy_e</strong> and <strong>e_pred</strong> for the reduced form results. As is typically the case, the measure of fit based on the reduced form predicted values is (slightly) worse than the naive one.</p>
<p>Other indications of the fit of the model (although strictly speaking not measures of fit) are the <strong>Log Likelihood</strong> (-2418.99), the <strong>Akaike info criterion</strong> (4849.97), and the <strong>Schwarz criterion</strong>, also sometimes referred to as BIC (4878.01). Compared to the results for the classic regression (respectively -2465.21, 4940.42, and 4963.79), the log-likelihood is clearly less negative (thus larger) and the AIC and SC are smaller (better) than their counterparts.</p>
<p>Other interesting attributes of the regression object are the regression coefficients, in <strong>betas</strong>, with the spatial autoregressive coefficient as the last element. The latter is also included separately as <strong>rho</strong>. The standard errors are in <strong>std_err</strong>, z-statistics and p-values in <strong>z_stat</strong>, and the complete variance-covariance matrix is <strong>vm</strong>.</p>
<p>The contents of the <strong>betas</strong> and <strong>rho</strong> attributes show how the estimate for <span class="math notranslate nohighlight">\(\rho\)</span> is also the last element in <strong>betas</strong>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(&quot;betas &quot;,lag1a.betas)
print(&quot;rho &quot;,lag1a.rho)
</pre></div>
</div>
</div>
<p>The Ord eigenvalue method is invoked by means of <code class="docutils literal notranslate"><span class="pre">method=&quot;ord&quot;</span></code>. All other attributes are the same as before (with again <code class="docutils literal notranslate"><span class="pre">spat_impacts</span> <span class="pre">=</span> <span class="pre">None</span></code>).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>t0 = time.time()
lag1b = ML_Lag(y,x,w=wq,method=&quot;ord&quot;,
                     name_w=w_name,name_ds=ds_name,
                     spat_impacts=None)
t1 = time.time()
print(&quot;Time in seconds: &quot;,t1-t0)
print(lag1b.summary)
</pre></div>
</div>
</div>
<p>The coefficient estimates are identical to those obtained with the <code class="docutils literal notranslate"><span class="pre">full</span></code> method. There are some slight differences in the computed standard errors (and thus also in the z-values and p-values), but the overall effect is minimal.</p>
<p>Again, all arguments are the same, except for <code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">&quot;LU&quot;</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>t0 = time.time()
lag1c = ML_Lag(y,x,w=wq,method=&quot;LU&quot;,
                     name_w=w_name,name_ds=ds_name,
                     spat_impacts=None)
t1 = time.time()
print(&quot;Time in seconds: &quot;,t1-t0)
print(lag1c.summary)
</pre></div>
</div>
</div>
<p>In this case, the estimation results are identical to those for the <code class="docutils literal notranslate"><span class="pre">full</span></code> method.</p>
<section id="Spatial-Multipliers---Impacts">
<h3>Spatial Multipliers - Impacts<a class="headerlink" href="#Spatial-Multipliers---Impacts" title="Link to this heading">¶</a></h3>
<p>In models that include a spatially lagged dependent variable Wy, with or without additional spatially lagged explanatory variables, the impact of a change in X on y is not simply the coefficient of X, as is the case in the standard regression model. Instead, the effect that results from changes in the neighboring values must also be accounted for. These are the <em>spatial multipliers</em>, <em>indirect effects</em> or <em>spatial impacts</em>.</p>
<p>In Kim, Phipps and Anselin (2003), it was shown that if the change in the explanatory variable is uniform across observations, the <em>spatial multiplier</em> is <span class="math notranslate nohighlight">\(1 / (1- \rho)\)</span>, with the total effect of a change in variable <span class="math notranslate nohighlight">\(x_k\)</span> amounting to <span class="math notranslate nohighlight">\(\beta_k / (1 - \rho)\)</span>. In the example, the spatial multiplier in the spatial lag model (<strong>lag1a</strong>) would be 1.0 / (1.0 - 0.39151) = 1.643.</p>
<p>The Kim et al. approach distinguishes between the direct effect, i.e., the coefficient of the <span class="math notranslate nohighlight">\(\beta\)</span> coefficients as estimated, and the total effect, which corresponds to this coefficient times the multiplier. An indirect effect is then the difference between the two.</p>
<p>LeSage and Pace (2009) introduce a slightly different set of concepts and use the terms average direct impact (<span class="math notranslate nohighlight">\(ADI\)</span>), average indirect impact (<span class="math notranslate nohighlight">\(AII\)</span>) and average total impact (<span class="math notranslate nohighlight">\(ATI\)</span>) as summaries computed from the matrix expression <span class="math notranslate nohighlight">\((I - \rho W)^{-1}\)</span> in the reduced form, <span class="math notranslate nohighlight">\((I - \rho W)^{-1}X\beta\)</span>. The main difference is that what they refer to as <em>direct</em> effect also includes some feedbacks as reflected in the diagonal elements of the inverse matris. As a result,
in their approach, the direct effects will differ from the estimates for <span class="math notranslate nohighlight">\(\beta\)</span>.</p>
<p>More formally, LeSage-Pace define <span class="math notranslate nohighlight">\(ADI\)</span> as the average trace of the inverse matrix, or, <span class="math notranslate nohighlight">\(ADI = (1/n) tr[(I - \rho W)^{-1}] = (1/n) \sum_i (I - \rho W)^{-1}_{ii}\)</span>. The <span class="math notranslate nohighlight">\(ATI\)</span> is the average of all the elements of the matrix, or, <span class="math notranslate nohighlight">\(ATI = (1/n) \sum_i \sum_j (I - \rho W)^{-1}\)</span>. Note that with some algebra, one can show that this equals <span class="math notranslate nohighlight">\(1 / (1 - \rho)\)</span>, the same as the total multiplier in the Kim et al. approach.</p>
<p>The <span class="math notranslate nohighlight">\(AII\)</span> then follows as <span class="math notranslate nohighlight">\(ATI - ADI\)</span>. The actual impacts are obtained by multiplying the <span class="math notranslate nohighlight">\(\beta\)</span> coefficient by respectively <span class="math notranslate nohighlight">\(ATI\)</span>, <span class="math notranslate nohighlight">\(ADI\)</span> and <span class="math notranslate nohighlight">\(AII\)</span>.</p>
<p>The impact measures are listed in the spatial lag regression output when the <code class="docutils literal notranslate"><span class="pre">spat_impacts</span></code> argument is specified (it is by default set to <code class="docutils literal notranslate"><span class="pre">spat_impacts</span> <span class="pre">=</span> <span class="pre">&quot;simple&quot;</span></code>). Options include <code class="docutils literal notranslate"><span class="pre">simple</span></code> (Kim et al. approach), <code class="docutils literal notranslate"><span class="pre">full</span></code> and <code class="docutils literal notranslate"><span class="pre">power</span></code> (both based on LeSage-Pace, but with <code class="docutils literal notranslate"><span class="pre">full</span></code> using a dense matrix computation for the inverse, whereas <code class="docutils literal notranslate"><span class="pre">power</span></code> uses a power approximation with higher order weights), as well as <code class="docutils literal notranslate"><span class="pre">all</span></code>, for all three. In addition, any combination of methods can be
passed in a list. For example, to obtain both Kim et al. and LeSage-Pace measures, the argument can be set as <code class="docutils literal notranslate"><span class="pre">spat_impacts</span> <span class="pre">=</span> <span class="pre">[&quot;simple&quot;,&quot;full&quot;]</span></code>, as in the listing below. Since the default setting is <code class="docutils literal notranslate"><span class="pre">spat_impacts</span> <span class="pre">=</span> <span class="pre">&quot;simple&quot;</span></code>, when listing the impacts is not desired, <code class="docutils literal notranslate"><span class="pre">spat_impacts</span></code> must explicitly be set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Based on extensive timing experiments for the LeSage-Pace approach, the <code class="docutils literal notranslate"><span class="pre">power</span></code> method is superior for data sets with more than 5,000 observations. For larger data sets, it quickly becomes the only viable option, being orders of magnitude faster than the brute force calculations. The Kim et al. approach has no such limitation, since it does not use any matrix calculations.</p>
<p>Note that the reported impacts are only <em>average</em> effects. See the spatial multipliers notebook for a more extensive analysis of the associated spatial pattern.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>lag2 = ML_Lag(y,x,w=wq,method=&quot;full&quot;,
                     name_w=w_name,name_ds=ds_name,
                     spat_impacts=[&#39;simple&#39;,&#39;full&#39;])
print(lag2.summary)
</pre></div>
</div>
</div>
<p>The listing of <strong>SPATIAL LAG MODEL IMPACTS</strong> for the <code class="docutils literal notranslate"><span class="pre">simple</span></code> and <code class="docutils literal notranslate"><span class="pre">full</span></code> methods clearly illustrates the slight differences between the two approaches. The <strong>Total</strong> effect is the same for both, but the distribution of the effect between <strong>Direct</strong> and <strong>Indirect</strong> is slightly different. For the <code class="docutils literal notranslate"><span class="pre">simple</span></code> method, the <strong>Direct</strong> effects are identical to the coefficient estimates, but for the <code class="docutils literal notranslate"><span class="pre">full</span></code> method, they are slightly larger. This is due to the use of the diagonal elements of the
inverse matrix, rather than the original estimates. As a result, some of the spillover feed-back effects are characterized as <strong>Direct</strong>. As a consequence, the part attributed to the <strong>Indirect</strong> effect is larger for the <code class="docutils literal notranslate"><span class="pre">simple</span></code> method than for the <code class="docutils literal notranslate"><span class="pre">full</span></code> method.</p>
<p>These measures should only be interpreted as rough indications of spatial spillovers since they are both based on a rather unrealistic assumption of a uniform change in the X-variable. Also, the <strong>Total</strong> effect is simply the original coefficient times the spatial multiplier. For example, for <strong>EP_LIMENG</strong>, this amounts to <span class="math notranslate nohighlight">\(0.3116 \times 1.643 = 0.512\)</span>.</p>
<p>This total effect can be compared to that implied by the SLX model, which would be the sum of <span class="math notranslate nohighlight">\(\beta\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span>. For example, for <strong>EP_LIMENG</strong>, this would be <span class="math notranslate nohighlight">\(0.38547 + 0.22040 = 0.60587\)</span>, which is actually larger than the total effect suggested by the spatial lag model. In part, this can be explained by recognizing that the SLX model is a truncated form of the reduced form for the spatial lag specification, i.e., only the first order contiguity elements are included. When
ignoring the remainder, its impact tends to be attributed to the coefficients of <span class="math notranslate nohighlight">\(\beta\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span>.</p>
</section>
<section id="Predicted-Values-and-Residuals">
<h3>Predicted Values and Residuals<a class="headerlink" href="#Predicted-Values-and-Residuals" title="Link to this heading">¶</a></h3>
<p>As mentioned, the <em>naive</em> predicted values and residuals are attributes of the regression object as <strong>predy</strong> and <strong>u</strong>. These are somewhat misleading, since they take the value of <span class="math notranslate nohighlight">\(Wy\)</span> as observed, in a so-called <em>conditional</em> approach. In the <em>simultaneous</em> spatial lag model, the spatial pattern for the dependent variable <span class="math notranslate nohighlight">\(y\)</span> is jointly determined as a function of the X-variables only. A predicted value that reflects this lesser degree of information is computed from the reduced
form, as <span class="math notranslate nohighlight">\(y_{pr} = (I - \hat{\rho} W)^{-1} X\hat{\beta}\)</span>. This is <strong>predy_e</strong> in the regression object. The associated forecast error, <span class="math notranslate nohighlight">\(y - y_{pr}\)</span> is <strong>e_pred</strong> in the regression object.</p>
<p>The two types of predicted values and residuals can be readily turned into a data frame by means of <code class="docutils literal notranslate"><span class="pre">pd.DataFrame</span></code> applied to an array constructed with <code class="docutils literal notranslate"><span class="pre">np.hstack</span></code>, in the same way as was done for the OLS predicted values and residuals. In the example, the associated variable names are <strong>ypred</strong>, <strong>yreduce</strong>, <strong>resid</strong> and <strong>forcerr</strong>, passed as the <code class="docutils literal notranslate"><span class="pre">columns</span></code> argument.</p>
<p>Descriptive statistics are obtained with <code class="docutils literal notranslate"><span class="pre">describe()</span></code></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>preds = pd.DataFrame(np.hstack((lag1a.predy,lag1a.predy_e,lag1a.u,lag1a.e_pred)),columns=[&#39;ypred&#39;,&#39;yreduce&#39;,&#39;resid&#39;,&#39;forcerr&#39;])
preds.describe()
</pre></div>
</div>
</div>
<p>Note some important differences between the two concepts. First, whereas the mean of <strong>ypred</strong> equals the mean of the actual dependent variable of 18.4852 (see <strong>Mean dependent var</strong> in the regression output listing), the mean of the reduced form prediction is slightly different (18.5128). Consequently, the mean of <strong>resid</strong> is essentially zero, but the mean of <strong>forcerr</strong> is slightly negative, at -0.0375. There are other slight differences as well.</p>
<p>The correlation between the two concepts is high, but not perfect, respectively 0.988 for the predicted values and 0.978 for the residuals.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(f&quot;Correlation between predicted values: {preds[&#39;ypred&#39;].corr(preds[&#39;yreduce&#39;]):0.3f}&quot;)
print(f&quot;Correlation between residuals:        {preds[&#39;resid&#39;].corr(preds[&#39;forcerr&#39;]):0.3f}&quot;)
</pre></div>
</div>
</div>
<section id="Spatial-pattern-of-residuals">
<h4>Spatial pattern of residuals<a class="headerlink" href="#Spatial-pattern-of-residuals" title="Link to this heading">¶</a></h4>
<p>A final interesting comparison is between the spatial pattern of the two types of residuals. To assess this, a simple Moran scatterplot is constructed, where the spatial lag is computed by means of <code class="docutils literal notranslate"><span class="pre">libpysal.lag_spatial</span></code>. The plot itself is constructed with <code class="docutils literal notranslate"><span class="pre">sns.regplot</span></code>, which superimposes a regression line on the scatter plot of the spatial lag on the original variable. No customization of the graph is carried out.</p>
<p>For the <em>naive</em> residuals, this yields the following plot.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>werr = lag_spatial(wq,preds[&#39;resid&#39;]).reshape(-1,1)
sns.regplot(x=preds[&#39;resid&#39;],y=werr)
plt.show()
</pre></div>
</div>
</div>
<p>The regression line is essentially flat, which means most/all of the remaining spatial correlation has been eliminated. In contrast, the Moran scatterplot for the prediction error shows a strong positive slope, suggesting remaining spatial clustering.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>wfor = lag_spatial(wq,preds[&#39;forcerr&#39;]).reshape(-1,1)
sns.regplot(x=preds[&#39;forcerr&#39;],y=wfor)
plt.show()
</pre></div>
</div>
</div>
<p>Why would this be the case? Recall that the predicted value is computed as <span class="math notranslate nohighlight">\(y_{pr} = (I - \hat{\rho} W)^{-1} X\hat{\beta}\)</span>. However, the complete expression for the reduced form is <span class="math notranslate nohighlight">\(y = (I - \rho W)^{-1} X\beta + (I - \rho W)^{-1}u\)</span>. Since the error term is unobserved and its mean is zero, the second term is ignored in the predicted value. As a result, the actual difference between <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(y_{pr}\)</span> is <span class="math notranslate nohighlight">\(e = (I - \rho W)^{-1}u\)</span>. This can be written as
<span class="math notranslate nohighlight">\(e = \rho We + u\)</span>, a spatial autoregressive process, which accounts for the spatial pattern in the residuals.</p>
<p>Since the residual is <em>not</em> filtered for the existing spatial correlation, it will remain spatially correlated itself. This is reflected in the positive slope of the regression line in the Moran scatter plot.</p>
</section>
<section id="Mapping-predicted-values-and-residuals">
<h4>Mapping predicted values and residuals<a class="headerlink" href="#Mapping-predicted-values-and-residuals" title="Link to this heading">¶</a></h4>
<p>Optionally, the predicted values and residuals can be added to the spatial data frame in order to construct associated maps. However, since these maps create only visual impressions of spatial patterning, this is not further pursued here.</p>
</section>
</section>
<section id="ML-Estimation-of-Spatial-Durbin-Model">
<h3>ML Estimation of Spatial Durbin Model<a class="headerlink" href="#ML-Estimation-of-Spatial-Durbin-Model" title="Link to this heading">¶</a></h3>
<p>ML estimation of the Spatial Durbin model is a special case of <code class="docutils literal notranslate"><span class="pre">spreg.ML_Lag</span></code>, with the additional argument of <code class="docutils literal notranslate"><span class="pre">slx_lags=1</span></code> (or a larger value). Everything else remains the same. More specifically, the three methods of <code class="docutils literal notranslate"><span class="pre">full</span></code>, <code class="docutils literal notranslate"><span class="pre">ord</span></code> and <code class="docutils literal notranslate"><span class="pre">LU</span></code> are again available. Only the default <code class="docutils literal notranslate"><span class="pre">full</span></code> is considered here. The results are essentially the same for the other methods.</p>
<p>To illustrate the difference between the two types of impact measures, <code class="docutils literal notranslate"><span class="pre">spat_impacts</span></code> is set to <code class="docutils literal notranslate"><span class="pre">[&quot;simple&quot;,&quot;full&quot;]</span></code> (note, the default setting remains <code class="docutils literal notranslate"><span class="pre">spat_impacts</span> <span class="pre">=</span> <span class="pre">&quot;simple&quot;</span></code>).</p>
<p>Another default setting is <code class="docutils literal notranslate"><span class="pre">spat_diag</span> <span class="pre">=</span> <span class="pre">True</span></code>, which yields the results for the Common Factor Hypothesis test. To avoid this test, <code class="docutils literal notranslate"><span class="pre">spat_diag</span></code> must be set to <code class="docutils literal notranslate"><span class="pre">False</span></code>. In the illustration, both arguments are listed explicitly for clarity.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>t0 = time.time()
spdur = ML_Lag(y,x,w=wq,slx_lags=1,
                    name_w=w_name,name_ds=ds_name,
                    spat_impacts = [&#39;simple&#39;,&#39;full&#39;],
                    spat_diag=True)
t1 = time.time()
print(&quot;Time in seconds: &quot;,t1-t0)
print(spdur.summary)
</pre></div>
</div>
</div>
<p>The inclusion of the spatial lag terms affects the results relative to both the original classic specification and the SLX model. The spatial autoregressive coefficient of 0.40 is highly significant. Similar to what happened in the SLX model relative to the classic specification, <strong>EP_NOHSDP</strong> and <strong>HIS_ct</strong> are no longer significant and neither is <strong>W_EP_NOVEH</strong>, but now <strong>W_EP_LIMENG</strong> is also no longer significant. As in the SLX specification, some of the signs and magnitudes of the WX
coefficients run counter to Tobler’s Law. According to the latter, the coefficients of <span class="math notranslate nohighlight">\(\beta\)</span> and the matching <span class="math notranslate nohighlight">\(\gamma\)</span> should be the same, which is not the case for <strong>EP_NOHSDP</strong> (but not significant) and <strong>EP_NOVEH</strong> (but the lag is not significant). A consistent pattern of opposite signs may be an indication that the common factor hypothesis holds (see below).</p>
<p>Relative to the standard Lag model, the inclusion of the WX terms makes the spatial autoregressive coefficient slightly larger (0.40 relative to 0.39), but it renders <strong>HIS_ct</strong> non-significant (this is similar to what happened in the SLX model relative to the classic specification).</p>
<p>Significance improves slightly relative to the SLX model, with a Log Likelihood of -2410.7 (compared to -2442.8), AIC of 4841.5 (relative to 4903.5), and SC of 4888.2 (relative to 4945.6).</p>
<p>As in the spatial Lag model, there will be two types of predicted values and residuals, respectively based on a naive approach and the reduced form. This is not considered further since the treatment and interpretation are identical to that in the standard spatial Lag model.</p>
<p>Further refinements of the model specification can be carried out by eliminating some lag terms by means of <code class="docutils literal notranslate"><span class="pre">slx_vars</span></code>, as in the SLX model. This is not further pursued here.</p>
</section>
</section>
<section id="id2">
<h2>Spatial Multipliers - Impacts<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<p>The impact measures for the Spatial Durbin model follow the same logic as in the spatial lag model. They are derived from the reduced form, which is now, ignoring the error term: <span class="math">\begin{equation*}
y = (I - \rho W)^{-1} X \beta + (I - \rho W)^{-1} WX \gamma.
\end{equation*}</span> The effect of this is that the various multipliers must be applied to both <span class="math notranslate nohighlight">\(\beta\)</span> and the matching <span class="math notranslate nohighlight">\(\gamma\)</span> to compute the overall impacts.</p>
<p>As it turns out, the total multiplier is the same as in the lag model, i.e., <span class="math notranslate nohighlight">\(1.0 / (1.0 - \rho)\)</span>. However, to get the total effect, this factor needs to be multiplied by both <span class="math notranslate nohighlight">\(\beta\)</span> and the matching <span class="math notranslate nohighlight">\(\gamma\)</span>.</p>
<p>For example, taking <span class="math notranslate nohighlight">\(\rho = 0.4044\)</span> as in the example, the total multiplier follows as <span class="math notranslate nohighlight">\(1.673\)</span>. The total impact for the variable <strong>EP_LIMENG</strong> (ignoring for now that <strong>W_LIMENG</strong> turned out to be non-significant) would be <span class="math notranslate nohighlight">\(1.673 \times 0.37397 + 1.673 \times 0.01243 = 0.6464\)</span>, the value given in the <strong>Total</strong> column of the impacts listing. As in the lag model, the total impact is the same for the Kim et al approach and the LeSage-Pace approach. The main difference is in the
way the direct effect is computed.</p>
<p>In the Kim et al approach, the direct effect is the coefficient of <span class="math notranslate nohighlight">\(\beta\)</span>. This is a strict interpretation of direct effect, i.e., it considers the effect of <span class="math notranslate nohighlight">\(\gamma\)</span> to be indirect. This is consistent with the interpretation of <span class="math notranslate nohighlight">\(\gamma\)</span> in the SLX model, but it is not the approach used by LeSage-Pace in their original treatment. In their formulation, the <span class="math notranslate nohighlight">\(ADI\)</span> is applied to both <span class="math notranslate nohighlight">\(\beta\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span> to compute the direct effect, typically yielding a larger
value for the direct effect (as long as <span class="math notranslate nohighlight">\(\beta\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span> have the same sign). This approach is <em>not</em> followed by <code class="docutils literal notranslate"><span class="pre">spreg</span></code>. Instead, the direct effect is obtained by multiplying the <span class="math notranslate nohighlight">\(ADI\)</span> with the <span class="math notranslate nohighlight">\(\beta\)</span> coefficient only. As a result, the share attributed to the indirect impact will be larger than in original the LeSage-Pace formulation (in contrast, the latter is followed in the <code class="docutils literal notranslate"><span class="pre">R</span></code> <code class="docutils literal notranslate"><span class="pre">spatialreg</span></code> package).</p>
<p>The total and direct/indirect impacts can be compared to those suggested by the simple spatial lag model and the SLX model. For example, for <strong>EP_LIMENG</strong>, the total impact of a uniform change in that variable was 0.606 in SLX, 0.512 in the spatial lag model and 0.646 in the spatial Durbin specification. Of this (using the Kim et al logic), 0.220 was spatial spillover (indirect effect) in SLX, 0.201 in spatial lag, and 0.272 in the spatial Durbin model.</p>
<p>As mentioned above, these impact measures are only summaries. A more meaningful indication of spatial spillovers would follow from a non-uniform change in (some of) the X variables through the use of the full reduced form. In addition, the average may mask some interesting spatial patterns, as demonstrated in an earlier notebook.</p>
</section>
<section id="Common-Factor-Hypothesis">
<h2>Common Factor Hypothesis<a class="headerlink" href="#Common-Factor-Hypothesis" title="Link to this heading">¶</a></h2>
<p>A complication in the interpretation of the spatial Durbin model occurs because the spatial autoregressive Error model has an equivalent counterpart as a spatial Lag formulation that includes WX terms, i.e., the same specification as the spatial Durbin model. Formally: <span class="math">\begin{equation*}
y = X \beta + (I - \lambda W)^{-1} u = \lambda Wy + X \beta - \lambda  WX \beta + u.
\end{equation*}</span> In this alternative specification, the coefficients for the <span class="math notranslate nohighlight">\(WX\)</span> variables correspond to the negative product of the autoregressive and the matching regression parameters (except for the constant term), the so-called <em>common factor constraint</em>.</p>
<p>Following Anselin(1988), the test on the common factor hypothesis <span class="math notranslate nohighlight">\(H_0: \rho \beta^* + \gamma = 0\)</span> (with <span class="math notranslate nohighlight">\(\beta^*\)</span> as the vector of regression coefficients without the constant term) consists of three elements:</p>
<ul class="simple">
<li><p>the constraint as a <span class="math notranslate nohighlight">\(h \times 1\)</span> vector <span class="math notranslate nohighlight">\(g = \hat{\rho} \hat{\beta}^* + \hat{\gamma}\)</span> (with <span class="math notranslate nohighlight">\(h = k-1\)</span>)</p></li>
<li><p>a <span class="math notranslate nohighlight">\(2h+1 \times h\)</span> matrix of partial derivatives:</p></li>
</ul>
<p><span class="math">\begin{equation*}
G = \begin{bmatrix}
\hat{\rho} \times I_h\\
I_h\\
\hat{\beta'}^*
\end{bmatrix}
\end{equation*}</span></p>
<ul class="simple">
<li><p>and the <span class="math notranslate nohighlight">\(2h+1 \times 2h+1\)</span> square asymptotic variance matrix <span class="math notranslate nohighlight">\(V\)</span> from the estimated spatial Durbin model (<strong>vm</strong> in the regression object)</p></li>
</ul>
<p>Using the delta method, the common factor statistic then follows as: <span class="math">\begin{equation*}
CF = g'[G'VG]^{-1}g  \sim \chi^2(h).
\end{equation*}</span> For our purposes, this suffices, although it should be noted that Juhl(2021) has pointed out potential problems due to the lack of invariance of the Wald test to different reparameterizations of the null hypothesis.</p>
<p>A test on the common factor hypothesis is included in the spatial Durbin output when <code class="docutils literal notranslate"><span class="pre">spat_diag</span> <span class="pre">=</span> <span class="pre">True</span></code>, which is the default for this specification.</p>
<p>In the example above, the value of the test statistic is 32.954, which strongly rejects the null. Some indication of the failure of the common factor hypothesis could also be gleaned from the lack of opposite signs of <span class="math notranslate nohighlight">\(\beta\)</span> and <span class="math notranslate nohighlight">\(\gamma\)</span>, which is necessary for the constraint to hold with a positive <span class="math notranslate nohighlight">\(\rho\)</span>.</p>
</section>
<section id="Likelihood-Ratio-Tests">
<h2>Likelihood-Ratio Tests<a class="headerlink" href="#Likelihood-Ratio-Tests" title="Link to this heading">¶</a></h2>
<p>A likelihood ratio test is <span class="math notranslate nohighlight">\(LR = 2.0 \times (LogL_1 - LogL_0)\)</span>, where <span class="math notranslate nohighlight">\(LogL_1\)</span> is the log-likelihood for the <em>unrestricted</em> model (i.e., with more non-zero parameters), and <span class="math notranslate nohighlight">\(LogL_0\)</span> is the log-likelihood for the <em>restricted</em> model (i.e., where some parameters, like <span class="math notranslate nohighlight">\(\rho\)</span>, are set to zero). For example, a likelihood ratio test on the coefficient <span class="math notranslate nohighlight">\(\rho\)</span> in the spatial lag model would use the log likelihood in the spatial lag model as <span class="math notranslate nohighlight">\(LogL_1\)</span>, and the
log-likelihood from the classic regression as <span class="math notranslate nohighlight">\(LogL_0\)</span>.</p>
<p>The <span class="math notranslate nohighlight">\(LR\)</span> statistic is distributed as a Chi-square random variable with degrees of freedom equal to the number of restrictions, i.e., 1 for the spatial autoregressive coefficient, but more for the SLX and spatial Durbin models, depending on how many explanatory variables are included. The LR tests are an alternative to the Wald tests (asymptotic t-values) on the spatial coefficient and the LM tests for spatial effects considered earlier.</p>
<p>A likelihood ratio test is implemented as <code class="docutils literal notranslate"><span class="pre">spreg.diagnostics.likratiotest</span></code>. Its two arguments are the regression object for the constrained model and the regression object for the unconstrained model. The result is a dictionary with the statistic (<code class="docutils literal notranslate"><span class="pre">likr</span></code>), the degrees of freedom (<code class="docutils literal notranslate"><span class="pre">df</span></code>) and the p-value (<code class="docutils literal notranslate"><span class="pre">p-value</span></code>)</p>
<p>Four different LR test consider the following constraints:</p>
<ul class="simple">
<li><p>Lag vs OLS, i.e., <span class="math notranslate nohighlight">\(\rho = 0\)</span> in the Lag model: arguments are <strong>ols1</strong> and <strong>lag2</strong></p></li>
<li><p>SDM vs OLS, i.e., both <span class="math notranslate nohighlight">\(\rho = 0\)</span> and <span class="math notranslate nohighlight">\(\gamma = 0\)</span> in the spatial Durbin model: argumentes are <strong>ols1</strong> and <strong>spdur</strong></p></li>
<li><p>SDM vs Lag, i.e., <span class="math notranslate nohighlight">\(\gamma = 0\)</span> in the spatial Durbin model: arguments are <strong>lag2</strong> and <strong>spdur</strong></p></li>
<li><p>SDM vs SLX, i.e., <span class="math notranslate nohighlight">\(\rho = 0\)</span> in the spatial Durbin model: arguments are <strong>slx1</strong> and <strong>spdur</strong></p></li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>LR_Lag = likratiotest(ols1,lag2)
LR_SDMO = likratiotest(ols1,spdur)
LR_SDML = likratiotest(lag2,spdur)
LR_SDMS = likratiotest(slx1,spdur)

print(f&quot;LR statistic Lag-OLS: {LR_Lag[&quot;likr&quot;]:0.3f}, d.f. {LR_Lag[&quot;df&quot;]:2d}, p-value {LR_Lag[&quot;p-value&quot;]:0.4f}&quot;)
print(f&quot;LR statistic SDM-OLS: {LR_SDMO[&quot;likr&quot;]:0.3f}, d.f. {LR_SDMO[&quot;df&quot;]:2d}, p-value {LR_SDMO[&quot;p-value&quot;]:0.4f}&quot;)
print(f&quot;LR statistic SDM-Lag: {LR_SDML[&quot;likr&quot;]:0.3f}, d.f. {LR_SDML[&quot;df&quot;]:2d}, p-value {LR_SDML[&quot;p-value&quot;]:0.4f}&quot;)
print(f&quot;LR statistic SDM-SLX: {LR_SDMS[&quot;likr&quot;]:0.3f}, d.f. {LR_SDMS[&quot;df&quot;]:2d}, p-value {LR_SDMS[&quot;p-value&quot;]:0.4f}&quot;)
</pre></div>
</div>
</div>
<p>In the current example, all null hypotheses are strongly rejected. Based on this evidence alone, it would suggest that the most appropriate specification is the spatial Durbin model. However, conflicts with the signs and magnitudes of the coefficients make that model difficult to interpret. Most importantly, several parameters violate Tobler’s law, one of the most important tenets of spatial analysis. While in and of itself this is not sufficient to dismiss the model specification, it does
require careful consideration of the interpretation.</p>
<p>The Likelihood Ratio, Wald (the square of the asymptotic t-ratio) and Lagrange Multiplier test statistics are considered to be <em>classic</em> tests. Asymptotically, they are equivalent, but in finite samples, they tend to follow the order LM &lt; LR &lt; W.</p>
<p>For the lag model in this example, the LM-Lag test statistic was 109.463, the Wald test was 9.922^2 or 98.446, and the LR test (above) 92.446. Whereas the LR and Wald test follow the prescribed order, the LM-Lag test does not, which may point to potential remaining specification problems.</p>
<p>As mentioned, the model can be refined by selectively setting <code class="docutils literal notranslate"><span class="pre">slx_vars</span></code>, but this is not pursued here.</p>
<section id="Practice">
<h3>Practice<a class="headerlink" href="#Practice" title="Link to this heading">¶</a></h3>
<p>While the ML estimation paradigm is very powerful, it also is not robust to various forms of misspecification. This is difficult to consider when the results are viewed in isolation, but it is important to keep in mind. As practice, different model specifications could be considered, including adding additional explanatory variables, selectively removing some lag terms, and using different spatial weights. Make sure to carefully consider the interpretation of the estimated coefficients and
associated direct and indirect effects.</p>
</section>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/notebooks/13_ML_estimation_spatial_lag.ipynb.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2018-, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 8.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>